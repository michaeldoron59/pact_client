import json
from tempfile import NamedTemporaryFile
import subprocess
import yaml as y
import numpy as np
from time import sleep
import requests
session = requests.Session()

node_list = ["api.chainweb.com", "kadena2.app.runonflux.io"]

class Client:
    def __init__(self, account_id=0, node=node_list[0], seed_file="./seed"):
        self.node = node
        self.network = "mainnet01"
        # public key generated by `$> keychain key seed 0`
        self.public = "5459fcea1d083cd82008dcd97654312f9a08d185160e7dc5e5769c062cb2de7e"
        self.account_id = account_id
        self.account = "k:" + self.public
        self.seed_file = seed_file



    def make_tx(self, code, signed, caps, chain, data, gas_limit, gas_price):
        tx = {
                "code": code,
                "data": data,
                "publicMeta": {
                    "chainId": str(chain),
                    "sender": self.account,
                    "gasLimit": gas_limit,
                    "gasPrice": gas_price,
                    "ttl": 150000
                },
                "networkId": self.network,
                "nonce": str(np.datetime64("now")),
                "type": "exec"
             }

        if signed:
            signers = {"signers": [{"public": self.public,
                                    "caps":caps}]}
            tx.update(signers)
            # print(tx)

        return tx


    @staticmethod
    def read_float(val):
        return float(val if isinstance(val, (float,int)) else float(val['decimal']))

    def send_tx(self, code, chains=[1], endpoint="local", signed=False, caps=[], data=None,
                gas_limit=10000, gas_price=1e-08):
        """

        :param code: string pact code
        :param chains: which chains to send the tx to
        :param endpoint: local/send/pact
        :param signed: bool: wheather to sign the tx or not
        :param caps: which caps should be added, format is [{"name":"coin.GAS", "args":[]}]
        :param data: data to append to the transaction
        :return: the list of raw responses from the node.
        """
        assert endpoint in ("local", "send", "pact"), endpoint

        ukw = dict(node=self.node, network=self.network, endpoint=endpoint)

        url = "https://{node}/chainweb/0.0/{network}/chain/{chain}/pact/api/v1/{endpoint}"

        if endpoint == "local":
            local = "-l"
        else:
            local = ""

        if data is None:
            data = {
                "keyset": {
                    "keys": [
                        self.public
                    ],
                    "pred": "keys-all"
                }
            }

        responses = []
        for chain in chains:
            yaml = y.dump(self.make_tx(code, signed=signed, caps=caps, chain=chain, data=data,
                                       gas_limit=gas_limit, gas_price=gas_price))
            # print(yaml)
            with NamedTemporaryFile(mode="w",suffix=".yaml") as f:
                # print(yaml)
                f.write(yaml)
                f.flush()
                if signed:
                    command = f'pact -u {f.name} | keychain sign -k {self.seed_file} -i {self.account_id} | pact combine-sigs {local} /dev/stdin'
                else:
                    command = f'pact {local} -a {f.name}'

                # print(subprocess.getoutput(command))
                j = json.loads(subprocess.getoutput(command))

                responses.append(session.post(url.format(chain=chain,**ukw), headers={"Content-Type":"application/json"}, json=j).content)

        return responses


    def poll_request(self, request_id):
        url = f"https://{self.node}/chainweb/0.0/{self.network}/chain/{self.chain}/pact/api/v1/poll"
        return session.post(url, headers={"Content-Type":"application/json"}, json=json.loads(request_id)).content
